<!DOCTYPE html>
<html lang="es">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Iván Martín">
    <meta name="description" content="Iván Martín personal website">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="UPV, Python y muchas fotos"/>
<meta name="twitter:description" content="Hace más o menos tres años, durante una clase de Introducción a la Programación, mandaron por el grupo de clase un enlace a una página hosteada en github. El contenido era un juego al estilo Facemash. Podéis acceder a lo que era el juego aquí.
Toda la clase se puso a jugar.
Al cabo de unos días la gente encargada de los sistemas hicieron cambios para que las fotos dejasen de ser accesibles sin autenticación."/>

    <meta property="og:title" content="UPV, Python y muchas fotos" />
<meta property="og:description" content="Hace más o menos tres años, durante una clase de Introducción a la Programación, mandaron por el grupo de clase un enlace a una página hosteada en github. El contenido era un juego al estilo Facemash. Podéis acceder a lo que era el juego aquí.
Toda la clase se puso a jugar.
Al cabo de unos días la gente encargada de los sistemas hicieron cambios para que las fotos dejasen de ser accesibles sin autenticación." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ivmg.me/posts/upv-facemash/" />
<meta property="article:published_time" content="2019-03-31T19:27:53+02:00" />
<meta property="article:modified_time" content="2019-03-31T19:27:53+02:00" />


    
      <base href="https://ivmg.me/posts/upv-facemash/">
    
    <title>
  UPV, Python y muchas fotos · Iván Martín
</title>

    
      <link rel="canonical" href="https://ivmg.me/posts/upv-facemash/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.11.2/css/all.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
    <script type="text/javascript" src="https://ivmg.me/js/prism.js"></script>

    
      
      
      <link rel="stylesheet" href="https://ivmg.me/css/coder.min.7b5f86f73bbb174510c0a12d83c1581ce053e2c2cb79a95b2327b8f7ebe4a967.css" integrity="sha256-e1&#43;G9zu7F0UQwKEtg8FYHOBT4sLLealbIye49&#43;vkqWc=" crossorigin="anonymous" media="screen" />
    

    

    
      
        
        
        <link rel="stylesheet" href="https://ivmg.me/css/coder-dark.min.83a2010dac9f59f943b3004cd6c4f230507ad036da635d3621401d42ec4e2835.css" integrity="sha256-g6IBDayfWflDswBM1sTyMFB60DbaY102IUAdQuxOKDU=" crossorigin="anonymous" media="screen" />
      
    

    

    

    

    <link rel="icon" type="image/png" href="https://ivmg.me/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://ivmg.me/favicons/favicon-16x16.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.62.2" />
  </head>

  
  
    
  
  <body class="colorscheme-auto">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://ivmg.me/">
      Iván Martín
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://ivmg.me/posts/">Blog</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">UPV, Python y muchas fotos</h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2019-03-31T19:27:53&#43;02:00'>
                March 31, 2019
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              6 minutos de lectura.
            </span>
          </div>
          
          
        </div>
      </header>

      <div>
        <p>Hace más o menos tres años, durante una clase de Introducción a la Programación, mandaron por el grupo de clase un enlace a una página hosteada en github. El contenido era un juego al estilo <a href="https://en.wikipedia.org/wiki/History_of_Facebook">Facemash</a>. Podéis acceder a lo que era el juego <a href="https://web.archive.org/web/20190323204003/http://tonilopezmr.github.io/facemash/">aquí</a>.</p>
<p><strong>Toda</strong> la clase se puso a jugar.</p>
<p>Al cabo de unos días la gente encargada de los sistemas hicieron cambios para que las fotos dejasen de ser accesibles sin autenticación. Cuando intentabas acceder a la fotografía de un usuario te devolvían esta imagen:</p>
<p><img src="https://ivmg.me/images/upv-facemash/no-available.png" alt="Link"></p>
<h4 id="demos-paso-a-la-chapuza-">Demos paso a: La chapuza 🛠</h4>
<p>Un año o dos después de que hiciesen los cambios, me dio por mirar bien lo que habían hecho para bloquear el acceso. Antes de indagar suponía que habrían requerido autenticación con el token de sesión y dado que ese token caduca, si a alguien le diese por usarlo para obtener todas las fotos sería tedioso. Además de que podrían ver quién es.</p>
<p>Primero necesitamos saber cómo se sirven las fotos.</p>
<p><img src="https://ivmg.me/images/upv-facemash/blurred-photos-link.png" alt="Link"></p>
<p>Vemos dos rutas que nos podrían valer: <code>/foto/orla/{id}.gif</code> y <code>/foto/getb/{id}.gif</code>. Además de ver cual es mi identificador: <code>55244399</code>.</p>
<p>Cada <em>asociado</em> tiene un identificador &ldquo;aleatorio&rdquo;, digo <em>asociado</em> porque el sistema almacena a alumnos, empleados del campus y profesores. En el caso de que pasemos un identificador que no esté asociado a un alumno se nos devolverá la imagen de no disponible.</p>
<p>Bien, ahora que ya sabemos cómo obtener fotos vamos a ver cómo las han protegido.</p>
<p>Como he comentado antes, al protegerlas asumí que lo habrían hecho con el token de sesión ya que al acceder haciendo clic en la foto se abre una nueva pestaña cargando la imagen. Lo raro viene, cuando al copiar el enlace que hemos visto anteriormente en una nueva pestaña y se te muestra que el recurso no está disponible.</p>
<p><img src="https://ivmg.me/images/upv-facemash/wait-what.gif" alt="Wait what"></p>
<p>Esto no tiene ningún sentido ya que si la autenticación se hiciese por algo que se guarda en el navegador daría igual que accediésemos a la foto copiando el enlace o clicando directamente.</p>
<p>Vamos a ver cómo se está haciendo la llamada exactamente. Desde el inspector, podemos copiar la petición exacta que ha hecho el navegador para obtener una imagen. Que en este caso, en formato cURL sería tal que:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl <span style="font-style:italic">&#39;https://intranet.upv.es/foto/getb/55244399.gif&#39;</span> -H <span style="font-style:italic">&#39;Pragma: no-cache&#39;</span> -H <span style="font-style:italic">&#39;Accept-Encoding: gzip, deflate, br&#39;</span> -H <span style="font-style:italic">&#39;Accept-Language: es-ES,es;q=0.9,en;q=0.8&#39;</span> -H <span style="font-style:italic">&#39;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36&#39;</span> -H <span style="font-style:italic">&#39;Accept: image/webp,image/apng,image/*,*/*;q=0.8&#39;</span> -H <span style="font-style:italic">&#39;Referer: https://intranet.upv.es/pls/soalu/sic_al.lis?p_vista=intranet&amp;p_idioma=c&amp;p_caca=2018&amp;P_asi=11566&amp;P_ACTION=generarorla&#39;</span> -H <span style="font-style:italic">&#39;Cookie: T=foto1; AMFParams=dummy,false,false,false,false,true,mac,10_14_2,chrome,73.0.3683.75; AMFDetect=true; TDp={token}; iacclarge=; UPV_DEBUG=,iacclarge; accesible=HighContrast&#39;</span> -H <span style="font-style:italic">&#39;Connection: keep-alive&#39;</span> -H <span style="font-style:italic">&#39;Cache-Control: no-cache&#39;</span> --compressed
</code></pre></div><p>Si quitamos las cosas que no nos interesan y le añadimos <code>--output foto.gif</code> para que nos descargue el archivo, nos quedariamos con:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl <span style="font-style:italic">&#39;https://intranet.upv.es/foto/getb/55244399.gif&#39;</span> -H <span style="font-style:italic">&#39;Referer: https://intranet.upv.es/pls/soalu/sic_al.lis?p_vista=intranet&amp;p_idioma=c&amp;p_caca=2018&amp;P_asi=11566&amp;P_ACTION=generarorla&#39;</span> -H <span style="font-style:italic">&#39;Cookie: TDp={token};&#39;</span> --output foto.gif
</code></pre></div><p>Llegados a este punto, tenemos dos headers: <code>Cookie: TDp</code> (el token?) y <code>Referrer</code>. Si sólo dejamos el parámetro <code>Referrer</code>, la fotografía se descarga, en cambio, quitándolo se nos devuelve la imagen de recurso no disponible. Por lo que la petición mínima con la que nos quedamos es:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl <span style="font-style:italic">&#39;https://intranet.upv.es/foto/getb/55244399.gif&#39;</span> -H <span style="font-style:italic">&#39;Referer: https://intranet.upv.es/pls/soalu/sic_al.lis&#39;</span> --output foto.gif
</code></pre></div><p>¿Qué ha pasado? Pues que, el arreglo que han hecho es añadir una cabecera para saber el origen desde el que se está accediendo al recurso.</p>
<p>Ni esto es el hackeo del siglo, ni ellos han hecho la mayor chapuza de la historia. Ahora ya no se puede insertar la foto en una web de forma directa y tampoco de forma dinámica porque (gracias a Dios) tienen el CORS configurado. Pero si lo que querían era proteger las fotos, sin duda se podría haber hecho mejor.</p>
<p>Ah, creo que los alumnos tienen la posibilidad de configurar una web en un subdominio de <code>*.upv.es</code>, así que 👋🏼 CORS.</p>
<h4 id="con-todos-ustedes-la-descarga-">Con todos ustedes: La descarga ⬇️</h4>
<p>Hora de montarse un dataset.</p>
<p>La idea es montar un script en python, pero un script rápido, muy rápido. Para ello vamos a usar <a href="https://docs.python.org/3/library/asyncio.html">asyncio</a>, <a href="https://aiohttp.readthedocs.io/en/stable/">aiohttp</a> para la comunicación, <a href="https://github.com/Tinche/aiofiles">aiofiles</a> para guardar las fotos y <a href="https://github.com/cgarciae/pypeln">pypeln</a> que nos ayudará con cómo aiohttp hace las llamadas.</p>
<p><em>Show me the code</em>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="font-weight:bold">import</span> <span style="font-weight:bold">asyncio</span>
<span style="font-weight:bold">import</span> <span style="font-weight:bold">hashlib</span>
<span style="font-weight:bold">import</span> <span style="font-weight:bold">sys</span>

<span style="font-weight:bold">import</span> <span style="font-weight:bold">aiofiles</span>
<span style="font-weight:bold">from</span> <span style="font-weight:bold">aiohttp</span> <span style="font-weight:bold">import</span> ClientSession, TCPConnector
<span style="font-weight:bold">from</span> <span style="font-weight:bold">pypeln</span> <span style="font-weight:bold">import</span> asyncio_task <span style="font-weight:bold">as</span> aio

urls = (f<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">https://intranet.upv.es/foto/getb/{i}.gif</span><span style="font-style:italic">&#34;</span> <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(int(sys.argv[1])))
headers = {<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">Referer</span><span style="font-style:italic">&#34;</span>: <span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">https://intranet.upv.es/pls/soalu/sic_al.lis</span><span style="font-style:italic">&#34;</span>}
hash_not_available = (
    <span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">12fc76fc961784a7568e6bbfe53559ec00e8819fdb807d44</span><span style="font-style:italic">&#34;</span>
    <span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">2735c465e938c5ee8ac060f7abe70c9fbe8b52d461379430</span><span style="font-style:italic">&#34;</span>
    <span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">637676399a793900d8221419fa5b50a5</span><span style="font-style:italic">&#34;</span>
)


async <span style="font-weight:bold">def</span> download(url, session):
    async <span style="font-weight:bold">with</span> session.get(url, headers=headers) <span style="font-weight:bold">as</span> response:
        response_file = await response.read()

        <span style="font-weight:bold">if</span> hashlib.blake2b(response_file).hexdigest() != hash_not_available:
            file_name = url.split(<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">/</span><span style="font-style:italic">&#34;</span>)[5]

            f = await aiofiles.open(f<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">photos/{file_name}</span><span style="font-style:italic">&#34;</span>, mode=<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">wb</span><span style="font-style:italic">&#34;</span>)

            await f.write(await response.read())
            await f.close()


aio.each(
    download,
    urls,
    workers=1_000,
    on_start=<span style="font-weight:bold">lambda</span>: ClientSession(connector=TCPConnector(limit=None)),
    on_done=<span style="font-weight:bold">lambda</span> _status, session: session.close(),
    run=True,
)
</code></pre></div><p>Vamos a ver en más detalle algunas partes.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">urls = ( f<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">https://intranet.upv.es/foto/getb/{i}.gif</span><span style="font-style:italic">&#34;</span> <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(int(sys.argv[1]))
)
</code></pre></div><p>Primero, tenemos que definir las URLs a las que queremos llamar, la idea es que al script se le pase por argumentos el número de IDs hasta el que queremos iterar, para que el script tenga principio y fin, aunque si queremos iterar todas las URLs ese id va a tener que ser <strong>bastante</strong> alto. Por lo que definimos un generador, el cual empezará en el cero y acabará en <code>numero_por_argumentos - 1</code>.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">headers = {<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">Referer</span><span style="font-style:italic">&#34;</span>: <span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">https://intranet.upv.es/pls/soalu/sic_al.lis</span><span style="font-style:italic">&#34;</span>}
</code></pre></div><p>Aquí estamos definiendo la cabecera <em>mágica</em> que nos va a permitir acceder al recurso.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">hash_not_available = <span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">12fc76fc961784a7568e6...</span><span style="font-style:italic">&#34;</span>
</code></pre></div><p>Bien, si queremos iterar sobre todos los identificadores que existen, nos vamos a encontrar muchas veces con la imagen de recurso no disponible, por lo que tenemos que encontrar alguna forma de filtrarla. Una forma rápida de hacerlo es comparando los hashes de los archivos, la función en concreto que vamos a usar es <a href="https://blake2.net/">BLAKE2b</a>. Calculamos el hash para dicha foto y lo dejamos guardado en una variable para su posterior uso.</p>
<p>La parte más interesante de la función de descarga es cuando comparamos que la imagen sea distinta a la de no disponible cuanto a la función de descarga es bastante simple, lo único interesante es cuando comparamos que la foto sea distinta a la de no disponible:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="font-weight:bold">if</span> hashlib.blake2b(response_file).hexdigest() != hash_not_available:
    ...
</code></pre></div><p>Además de coger el identificador de la url que estemos buscando en ese momento:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">file_name = url.split(<span style="font-style:italic"></span><span style="font-style:italic">&#34;</span><span style="font-style:italic">/</span><span style="font-style:italic">&#34;</span>)[5]
</code></pre></div><p>Por último, usamos pypeln para organizar el cómo se van a hacer las llamadas:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">aio.each(
    download,
    urls,
    workers=1_000,
    ...
)
</code></pre></div><p>Es interesante el parámetro <code>workers</code>, para especificar que de forma concurrente solamente queremos estar scrapeando 1000 direcciones (que no son pocas). Cuando una de las tareas abiertas se completen se irán lanzando nuevas hasta llegar a este límite.</p>
<p>Aquí podeis ver cómo scrapea 2.000 IDs:</p>
<p><a href="https://asciinema.org/a/239886"><img src="https://asciinema.org/a/239886.svg" alt="asciicast"></a></p>
<p>Tenéis todo el código en este repo: <a href="https://github.com/seik/upv-facemash-downloader">https://github.com/seik/upv-facemash-downloader</a></p>
<p><!-- raw HTML omitted -->Disclamer: Este post se ha hecho con fines educativos. Excepto mi foto, el resto de imágenes han sido ocultadas (y eliminadas de mis sistemas) por cuestiones de privacidad. Los encargados de los sistemas de la UPV llevan notificados desde Junio de 2018, por lo que se considera que conocen los peligros de esta implementación.<!-- raw HTML omitted --></p>

      </div>

      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
    
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
